import aiohttp
import asyncio
import logging
from typing import Dict, Optional
from datetime import datetime, timedelta
import json

logger = logging.getLogger(__name__)

class CurrencyConverter:
    """–ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä –≤–∞–ª—é—Ç —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∫—É—Ä—Å–æ–≤"""
    
    def __init__(self):
        self.cache = {}
        self.cache_duration = timedelta(hours=1)  # –û–±–Ω–æ–≤–ª—è–µ–º –∫—É—Ä—Å—ã –∫–∞–∂–¥—ã–π —á–∞—Å
        self.last_update = None
        
        # –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –≤–∞–ª—é—Ç –∫ –∏—Ö –∫–æ–¥–∞–º
        self.currency_codes = {
            "—Å–æ–º": "KGS",
            "—Ç–µ–Ω–≥–µ": "KZT", 
            "—Ä—É–±.": "RUB"
        }
        
        # –ë–∞–∑–æ–≤—ã–µ –∫—É—Ä—Å—ã (fallback –µ—Å–ª–∏ API –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç)
        self.fallback_rates = {
            "KGS_to_KZT": 5.5,  # 1 —Å–æ–º = 5.5 —Ç–µ–Ω–≥–µ
            "KGS_to_RUB": 1.1,  # 1 —Å–æ–º = 1.1 —Ä—É–±–ª—è
            "KZT_to_RUB": 0.22, # 1 —Ç–µ–Ω–≥–µ = 0.22 —Ä—É–±–ª—è
        }
    
    async def get_exchange_rates(self) -> Dict[str, float]:
        """–ü–æ–ª—É—á–∞–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç —á–µ—Ä–µ–∑ API"""
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π API exchangerate-api.com
            async with aiohttp.ClientSession() as session:
                # –ü–æ–ª—É—á–∞–µ–º –∫—É—Ä—Å—ã –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ USD
                url = "https://api.exchangerate-api.com/v4/latest/USD"
                async with session.get(url, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        rates = data.get('rates', {})
                        
                        # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω—É–∂–Ω—ã–µ –∫—É—Ä—Å—ã
                        usd_to_kgs = rates.get('KGS', 84.0)  # –ü—Ä–∏–º–µ—Ä–Ω—ã–π –∫—É—Ä—Å
                        usd_to_kzt = rates.get('KZT', 460.0)  # –ü—Ä–∏–º–µ—Ä–Ω—ã–π –∫—É—Ä—Å
                        usd_to_rub = rates.get('RUB', 95.0)   # –ü—Ä–∏–º–µ—Ä–Ω—ã–π –∫—É—Ä—Å
                        
                        # –í—ã—á–∏—Å–ª—è–µ–º –∫—Ä–æ—Å—Å-–∫—É—Ä—Å—ã
                        exchange_rates = {
                            "KGS_to_KZT": usd_to_kzt / usd_to_kgs,
                            "KGS_to_RUB": usd_to_rub / usd_to_kgs,
                            "KZT_to_RUB": usd_to_rub / usd_to_kzt,
                            "KZT_to_KGS": usd_to_kgs / usd_to_kzt,
                            "RUB_to_KGS": usd_to_kgs / usd_to_rub,
                            "RUB_to_KZT": usd_to_kzt / usd_to_rub,
                        }
                        
                        logger.info("–ö—É—Ä—Å—ã –≤–∞–ª—é—Ç —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ API")
                        self.cache = exchange_rates
                        self.last_update = datetime.now()
                        return exchange_rates
                        
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤ —á–µ—Ä–µ–∑ API: {e}")
        
        # –ï—Å–ª–∏ API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback –∫—É—Ä—Å—ã
        logger.info("–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ä–µ–∑–µ—Ä–≤–Ω—ã–µ –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç")
        return {
            **self.fallback_rates,
            "KZT_to_KGS": 1 / self.fallback_rates["KGS_to_KZT"],
            "RUB_to_KGS": 1 / self.fallback_rates["KGS_to_RUB"],
            "RUB_to_KZT": 1 / self.fallback_rates["KZT_to_RUB"],
        }
    
    async def is_cache_valid(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –∫—ç—à–∞ –∫—É—Ä—Å–æ–≤"""
        if not self.last_update or not self.cache:
            return False
        return datetime.now() - self.last_update < self.cache_duration
    
    async def get_cached_rates(self) -> Dict[str, float]:
        """–ü–æ–ª—É—á–∞–µ—Ç –∫—É—Ä—Å—ã –∏–∑ –∫—ç—à–∞ –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –∏—Ö"""
        if not await self.is_cache_valid():
            self.cache = await self.get_exchange_rates()
        return self.cache
    
    async def convert_currency(self, amount: float, from_currency: str, to_currency: str) -> float:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –∏–∑ –æ–¥–Ω–æ–π –≤–∞–ª—é—Ç—ã –≤ –¥—Ä—É–≥—É—é"""
        if from_currency == to_currency:
            return amount
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–¥—ã –≤–∞–ª—é—Ç
        from_code = self.currency_codes.get(from_currency)
        to_code = self.currency_codes.get(to_currency)
        
        if not from_code or not to_code:
            logger.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –≤–∞–ª—é—Ç–∞: {from_currency} -> {to_currency}")
            return amount
        
        # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –∫—É—Ä—Å—ã
        rates = await self.get_cached_rates()
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–ª—é—á –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫—É—Ä—Å–∞
        rate_key = f"{from_code}_to_{to_code}"
        
        if rate_key in rates:
            converted_amount = amount * rates[rate_key]
            logger.info(f"–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è: {amount} {from_currency} = {converted_amount:.2f} {to_currency} (–∫—É—Ä—Å: {rates[rate_key]:.4f})")
            return round(converted_amount, 2)
        
        logger.error(f"–ö—É—Ä—Å {rate_key} –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return amount
    
    def get_currency_symbol(self, currency: str) -> str:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–∏–º–≤–æ–ª –≤–∞–ª—é—Ç—ã"""
        symbols = {
            "—Å–æ–º": "üá∞üá¨",
            "—Ç–µ–Ω–≥–µ": "üá∞üáø",
            "—Ä—É–±.": "üá∑üá∫"
        }
        return symbols.get(currency, "üí∞")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω–≤–µ—Ä—Ç–µ—Ä–∞
converter = CurrencyConverter()

async def convert_booster_balance(amount: float, from_currency: str, to_currency: str) -> float:
    """–£–¥–æ–±–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –±–∞–ª–∞–Ω—Å–∞ –±—É—Å—Ç–µ—Ä–∞"""
    return await converter.convert_currency(amount, from_currency, to_currency)

async def get_current_rates() -> Dict[str, float]:
    """–ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–∏–µ –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç"""
    return await converter.get_cached_rates()
